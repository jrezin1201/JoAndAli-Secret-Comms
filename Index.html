<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhisperNet - Secure Messaging</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 min-h-screen">
    <div id="app"></div>

```
<script>
    // ============================================
    // ENCRYPTION MODULE
    // ============================================
    class E2EEncryption {
        constructor() {
            this.keyPair = null;
            this.sharedKeys = {};
        }

        async init() {
            this.keyPair = await window.crypto.subtle.generateKey(
                { name: "ECDH", namedCurve: "P-256" },
                true,
                ["deriveKey", "deriveBits"]
            );
        }

        async getPublicKey() {
            const exported = await window.crypto.subtle.exportKey("raw", this.keyPair.publicKey);
            return this.arrayBufferToBase64(exported);
        }

        async deriveSharedKey(peerPublicKeyB64) {
            const peerPublicKey = await window.crypto.subtle.importKey(
                "raw",
                this.base64ToArrayBuffer(peerPublicKeyB64),
                { name: "ECDH", namedCurve: "P-256" },
                false,
                []
            );

            return await window.crypto.subtle.deriveKey(
                { name: "ECDH", public: peerPublicKey },
                this.keyPair.privateKey,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
        }

        async encrypt(message, sharedKey) {
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encoded = new TextEncoder().encode(message);
            
            const ciphertext = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                sharedKey,
                encoded
            );

            return {
                ciphertext: this.arrayBufferToBase64(ciphertext),
                iv: this.arrayBufferToBase64(iv)
            };
        }

        async decrypt(encryptedData, sharedKey) {
            const ciphertext = this.base64ToArrayBuffer(encryptedData.ciphertext);
            const iv = this.base64ToArrayBuffer(encryptedData.iv);

            const decrypted = await window.crypto.subtle.decrypt(
                { name: "AES-GCM", iv: iv },
                sharedKey,
                ciphertext
            );

            return new TextDecoder().decode(decrypted);
        }

        async getFingerprint() {
            const publicKeyRaw = await window.crypto.subtle.exportKey("raw", this.keyPair.publicKey);
            const hash = await window.crypto.subtle.digest("SHA-256", publicKeyRaw);
            const hashArray = Array.from(new Uint8Array(hash));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 16).toUpperCase();
        }

        arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }
    }

    // ============================================
    // STATE & SETUP
    // ============================================
    let state = {
        joined: false,
        roomId: '',
        username: '',
        messages: [],
        peers: {},
        myFingerprint: '',
        showFingerprints: false,
        connectionStatus: 'disconnected'
    };

    let ws = null;
    let peerConnections = {};
    let dataChannels = {};
    let crypto = new E2EEncryption();

    const SIGNALING_SERVER = 'wss://ancient-basin-production.up.railway.app';

    const rtcConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };

    async function init() {
        await crypto.init();
        state.myFingerprint = await crypto.getFingerprint();
    }

    // ============================================
    // WEBRTC & MESSAGING
    // ============================================
    function createPeerConnection(peerId) {
        const pc = new RTCPeerConnection(rtcConfig);

        pc.onicecandidate = (event) => {
            if (event.candidate && ws?.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'ice-candidate',
                    candidate: event.candidate,
                    to: peerId
                }));
            }
        };

        pc.ondatachannel = (event) => {
            setupDataChannel(event.channel, peerId);
        };

        pc.onconnectionstatechange = () => {
            updateConnectionStatus();
        };

        peerConnections[peerId] = pc;
        return pc;
    }

    function setupDataChannel(channel, peerId) {
        channel.onopen = async () => {
            const myPublicKey = await crypto.getPublicKey();
            channel.send(JSON.stringify({ type: 'key-exchange', publicKey: myPublicKey }));
            updateConnectionStatus();
        };

        channel.onmessage = async (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'key-exchange') {
                const sharedKey = await crypto.deriveSharedKey(data.publicKey);
                crypto.sharedKeys[peerId] = sharedKey;
                
                const peerKeyRaw = crypto.base64ToArrayBuffer(data.publicKey);
                const hash = await window.crypto.subtle.digest("SHA-256", peerKeyRaw);
                const hashArray = Array.from(new Uint8Array(hash));
                const fingerprint = hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 16).toUpperCase();
                
                state.peers[peerId] = { ...state.peers[peerId], fingerprint };
                addMessage({ 
                    text: `🔐 Secured connection with ${state.peers[peerId].username}`, 
                    system: true 
                });
            } else if (data.type === 'encrypted-message') {
                const sharedKey = crypto.sharedKeys[peerId];
                if (sharedKey) {
                    try {
                        const decrypted = await crypto.decrypt(data.encrypted, sharedKey);
                        const msgData = JSON.parse(decrypted);
                        addMessage({
                            username: msgData.username,
                            text: msgData.text,
                            timestamp: new Date(msgData.timestamp),
                            self: false
                        });
                    } catch (e) {
                        console.error('Decryption failed:', e);
                    }
                }
            }
        };

        dataChannels[peerId] = channel;
    }

    function updateConnectionStatus() {
        const connectedPeers = Object.values(dataChannels).filter(ch => ch.readyState === 'open').length;
        state.connectionStatus = connectedPeers > 0 ? 'connected' : 'connecting';
        render();
    }

    async function joinRoom() {
        if (!state.username.trim() || !state.roomId.trim()) return;

        state.connectionStatus = 'connecting';
        ws = new WebSocket(SIGNALING_SERVER);

        ws.onopen = () => {
            ws.send(JSON.stringify({
                type: 'join',
                room: state.roomId,
                username: state.username
            }));
            state.joined = true;
            addMessage({ text: `🔐 Your fingerprint: ${state.myFingerprint}`, system: true });
            addMessage({ text: 'Connecting to peers...', system: true });
            render();
        };

        ws.onmessage = async (event) => {
            const data = JSON.parse(event.data);

            switch (data.type) {
                case 'peers':
                    for (const peer of data.peers) {
                        if (peer.id !== state.username) {
                            state.peers[peer.id] = { username: peer.username };
                            const pc = createPeerConnection(peer.id);
                            const channel = pc.createDataChannel('messages');
                            setupDataChannel(channel, peer.id);
                            const offer = await pc.createOffer();
                            await pc.setLocalDescription(offer);
                            ws.send(JSON.stringify({ type: 'offer', offer, to: peer.id }));
                        }
                    }
                    render();
                    break;

                case 'peer-joined':
                    state.peers[data.peer.id] = { username: data.peer.username };
                    addMessage({ text: `${data.peer.username} joined`, system: true });
                    render();
                    break;

                case 'peer-left':
                    delete state.peers[data.peerId];
                    peerConnections[data.peerId]?.close();
                    delete peerConnections[data.peerId];
                    delete dataChannels[data.peerId];
                    delete crypto.sharedKeys[data.peerId];
                    addMessage({ text: `${data.username} left`, system: true });
                    updateConnectionStatus();
                    break;

                case 'offer':
                    const pc = createPeerConnection(data.from);
                    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    ws.send(JSON.stringify({ type: 'answer', answer, to: data.from }));
                    break;

                case 'answer':
                    await peerConnections[data.from].setRemoteDescription(
                        new RTCSessionDescription(data.answer)
                    );
                    break;

                case 'ice-candidate':
                    if (peerConnections[data.from]) {
                        await peerConnections[data.from].addIceCandidate(
                            new RTCIceCandidate(data.candidate)
                        );
                    }
                    break;
            }
        };

        ws.onerror = () => {
            addMessage({ text: '⚠️ Connection error. Please try again.', system: true });
            state.connectionStatus = 'disconnected';
            render();
        };
    }

    async function sendMessage(text) {
        if (!text.trim()) return;

        const message = {
            username: state.username,
            text: text,
            timestamp: new Date().toISOString()
        };

        let sentCount = 0;
        for (const [peerId, channel] of Object.entries(dataChannels)) {
            if (channel.readyState === 'open' && crypto.sharedKeys[peerId]) {
                try {
                    const encrypted = await crypto.encrypt(JSON.stringify(message), crypto.sharedKeys[peerId]);
                    channel.send(JSON.stringify({ type: 'encrypted-message', encrypted }));
                    sentCount++;
                } catch (e) {
                    console.error('Encryption failed:', e);
                }
            }
        }

        if (sentCount > 0) {
            addMessage({ username: state.username, text, timestamp: new Date(), self: true });
        } else {
            addMessage({ text: '⚠️ No active connections. Message not sent.', system: true });
        }
    }

    function addMessage(msg) {
        state.messages.push({ ...msg, id: Date.now() + Math.random() });
        render();
        setTimeout(() => {
            const container = document.getElementById('messages');
            if (container) container.scrollTop = container.scrollHeight;
        }, 10);
    }

    function generateRoomId() {
        state.roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
        render();
    }

    function toggleFingerprints() {
        state.showFingerprints = !state.showFingerprints;
        render();
    }

    function copyRoomId() {
        navigator.clipboard.writeText(state.roomId);
        const btn = document.getElementById('copyBtn');
        if (btn) {
            const original = btn.innerHTML;
            btn.innerHTML = '✓ Copied!';
            setTimeout(() => btn.innerHTML = original, 2000);
        }
    }

    // ============================================
    // RENDER
    // ============================================
    function render() {
        const app = document.getElementById('app');
        
        if (!state.joined) {
            app.innerHTML = `
                <div class="min-h-screen flex items-center justify-center p-4">
                    <div class="bg-slate-800/50 backdrop-blur-xl rounded-3xl shadow-2xl p-8 w-full max-w-md border border-purple-500/20">
                        <div class="text-center mb-8">
                            <div class="w-20 h-20 bg-gradient-to-br from-purple-500 to-pink-500 rounded-2xl flex items-center justify-center mx-auto mb-4 shadow-lg shadow-purple-500/50">
                                <svg class="text-white" width="40" height="40" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                            </div>
                            <h1 class="text-4xl font-bold text-white mb-2">WhisperNet</h1>
                            <p class="text-purple-300">Encrypted peer-to-peer messaging</p>
                        </div>

                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-semibold text-purple-200 mb-2">Your Name</label>
                                <input 
                                    type="text" 
                                    id="username" 
                                    placeholder="Enter your name"
                                    value="${state.username}"
                                    class="w-full px-4 py-3 bg-slate-700/50 border border-purple-500/30 rounded-xl text-white placeholder-slate-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500/20 outline-none transition"
                                    onkeypress="if(event.key==='Enter') handleJoin()"
                                />
                            </div>

                            <div>
                                <label class="block text-sm font-semibold text-purple-200 mb-2">Room ID</label>
                                <div class="flex gap-2">
                                    <input 
                                        type="text" 
                                        id="roomId" 
                                        placeholder="Enter or generate"
                                        value="${state.roomId}"
                                        class="flex-1 px-4 py-3 bg-slate-700/50 border border-purple-500/30 rounded-xl text-white placeholder-slate-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500/20 outline-none transition"
                                        onkeypress="if(event.key==='Enter') handleJoin()"
                                    />
                                    <button 
                                        onclick="generateRoomId()" 
                                        class="px-4 py-3 bg-slate-700/50 hover:bg-slate-600/50 border border-purple-500/30 rounded-xl font-medium text-white transition"
                                    >
                                        Generate
                                    </button>
                                </div>
                                ${state.roomId ? `
                                    <button 
                                        id="copyBtn"
                                        onclick="copyRoomId()" 
                                        class="mt-2 text-sm text-purple-300 hover:text-purple-200 transition"
                                    >
                                        📋 Copy Room ID
                                    </button>
                                ` : ''}
                            </div>

                            <button 
                                onclick="handleJoin()" 
                                class="w-full bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white font-bold py-4 rounded-xl transition-all transform hover:scale-105 shadow-lg shadow-purple-500/30"
                            >
                                Join Encrypted Room
                            </button>
                        </div>

                        <div class="mt-8 pt-6 border-t border-purple-500/20">
                            <div class="flex items-center justify-center gap-2 text-xs text-emerald-400 mb-2 font-semibold">
                                <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"></path>
                                </svg>
                                End-to-End Encrypted
                            </div>
                            <p class="text-xs text-slate-400 text-center">
                                Messages encrypted before leaving your device. No servers store your conversations.
                            </p>
                        </div>
                    </div>
                </div>
            `;
        } else {
            const statusColor = state.connectionStatus === 'connected' ? 'text-emerald-400' : 
                               state.connectionStatus === 'connecting' ? 'text-yellow-400' : 'text-red-400';
            const statusIcon = state.connectionStatus === 'connected' ? '●' : '○';

            app.innerHTML = `
                <div class="min-h-screen flex flex-col">
                    <div class="bg-slate-800/80 backdrop-blur-xl border-b border-purple-500/20 px-4 sm:px-6 py-4">
                        <div class="flex justify-between items-center">
                            <div class="flex-1">
                                <div class="flex items-center gap-3">
                                    <div class="w-10 h-10 bg-gradient-to-br from-purple-500 to-pink-500 rounded-xl flex items-center justify-center shadow-lg shadow-purple-500/50">
                                        <svg class="text-white" width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                        </svg>
                                    </div>
                                    <div>
                                        <h2 class="text-lg font-bold text-white">Room: ${state.roomId}</h2>
                                        <div class="flex items-center gap-3 text-sm">
                                            <span class="${statusColor}">${statusIcon} ${state.connectionStatus}</span>
                                            <span class="text-slate-400">${Object.keys(state.peers).length + 1} in room</span>
                                        </div>
                                    </div>
                                </div>
                                <button 
                                    onclick="toggleFingerprints()" 
                                    class="mt-2 text-xs text-purple-300 hover:text-purple-200 transition"
                                >
                                    ${state.showFingerprints ? '🔒 Hide' : '🔓 Show'} Fingerprints
                                </button>
                            </div>
                            <button 
                                onclick="location.reload()" 
                                class="px-4 py-2 bg-red-500/20 hover:bg-red-500/30 text-red-300 rounded-lg font-medium transition border border-red-500/30"
                            >
                                Leave
                            </button>
                        </div>
                        
                        ${state.showFingerprints ? `
                            <div class="mt-4 bg-slate-900/50 rounded-xl p-4 border border-purple-500/20">
                                <div class="font-bold text-purple-200 mb-3 text-sm">🔐 Verify Fingerprints:</div>
                                <div class="space-y-2">
                                    <div class="bg-slate-800/50 p-3 rounded-lg">
                                        <span class="font-semibold text-white text-sm">You:</span> 
                                        <code class="text-xs text-emerald-400 ml-2">${state.myFingerprint}</code>
                                    </div>
                                    ${Object.entries(state.peers).map(([id, peer]) => `
                                        <div class="bg-slate-800/50 p-3 rounded-lg">
                                            <span class="font-semibold text-white text-sm">${peer.username}:</span> 
                                            <code class="text-xs text-emerald-400 ml-2">${peer.fingerprint || 'Connecting...'}</code>
                                        </div>
                                    `).join('')}
                                </div>
                                <p class="text-xs text-purple-300 mt-3">⚠️ Verify these match via phone call to prevent MITM attacks</p>
                            </div>
                        ` : ''}
                    </div>

                    <div class="flex-1 overflow-y-auto p-4 sm:p-6 space-y-4" id="messages" style="background: linear-gradient(to bottom, rgba(15, 23, 42, 0.95), rgba(88, 28, 135, 0.1));">
                        ${state.messages.map(msg => `
                            <div class="${msg.system ? 'flex justify-center' : msg.self ? 'flex justify-end' : 'flex justify-start'}">
                                ${msg.system ? `
                                    <div class="text-sm text-slate-400 bg-slate-800/50 backdrop-blur-sm px-4 py-2 rounded-full max-w-md border border-purple-500/20">
                                        ${msg.text}
                                    </div>
                                ` : `
                                    <div class="max-w-xs lg:max-w-md">
                                        <div class="text-xs ${msg.self ? 'text-right' : 'text-left'} text-slate-400 mb-1 px-1">${msg.username}</div>
                                        <div class="px-4 py-3 rounded-2xl ${msg.self ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-br-sm shadow-lg shadow-purple-500/30' : 'bg-slate-700/70 backdrop-blur-sm text-white rounded-bl-sm border border-purple-500/20'}">
                                            ${msg.text}
                                        </div>
                                        <div class="text-xs ${msg.self ? 'text-right' : 'text-left'} text-slate-500 mt-1 px-1">
                                            ${msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                        </div>
                                    </div>
                                `}
                            </div>
                        `).join('')}
                    </div>

                    <div class="bg-slate-800/80 backdrop-blur-xl border-t border-purple-500/20 px-4 sm:px-6 py-4">
                        <div class="flex gap-2">
                            <input 
                                type="text" 
                                id="messageInput" 
                                placeholder="Type encrypted message..."
                                class="flex-1 px-4 py-3 bg-slate-700/50 border border-purple-500/30 rounded-xl text-white placeholder-slate-400 focus:border-purple-500 focus:ring-2 focus:ring-purple-500/20 outline-none transition"
                                onkeypress="if(event.key==='Enter') handleSend()"
                            />
                            <button 
                                onclick="handleSend()" 
                                class="px-6 py-3 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white rounded-xl font-medium transition-all transform hover:scale-105 shadow-lg shadow-purple-500/30"
                            >
                                Send
                            </button>
                        </div>
                        <div class="flex items-center justify-center gap-2 text-xs text-emerald-400 mt-3">
                            <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"></path>
                            </svg>
                            AES-256-GCM Encrypted
                        </div>
                    </div>
                </div>
            `;
        }
    }

    function handleJoin() {
        const usernameInput = document.getElementById('username');
        const roomIdInput = document.getElementById('roomId');
        if (usernameInput) state.username = usernameInput.value.trim();
        if (roomIdInput) state.roomId = roomIdInput.value.trim().toUpperCase();
        if (state.username && state.roomId) joinRoom();
    }

    function handleSend() {
        const input = document.getElementById('messageInput');
        if (input && input.value.trim()) {
            sendMessage(input.value);
            input.value = '';
        }
    }

    // Initialize and render
    init().then(() => render());
</script>
```

</body>
</html>